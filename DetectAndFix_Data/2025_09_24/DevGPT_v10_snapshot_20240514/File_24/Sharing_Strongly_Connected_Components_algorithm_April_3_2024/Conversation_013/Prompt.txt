Please compare your last result with the following code:
		std::vector<std::tuple<NodeType, LinkType, bool>> stack; // Node, CurrentLink, didVisitLink
		OwningPtrSizedArray< std::pair < PartType, PartType>> timedParLinkLinkedList; // avoid using a std::set for the partLinks from currentPart

		for (NodeType v = 0; v != nrV; ++v)
		{
			if (IsDefined(indices[v].first))
				continue;
			// Initial visit actions (similar to the start of the recursive function)
			indices[v] = { currIndex, currIndex }; // Set the depth index for v to the smallest unused index
			++currIndex;
			nodeStack.emplace_back(v);
			assert(!onStackFlag[v]);
			onStackFlag[v] = true;
			stack.emplace_back(v, link1[v], false); // Start with first visit of v
			while (!stack.empty()) {
				auto& [v, currentLink, didVisitLink] = stack.back();
				// Processing neighbors or finishing up
			retry:
				if (IsDefined(currentLink)) {
					NodeType w = node2Data[currentLink];

					if (didVisitLink)
					{ 
						MakeMin(indices[v].second, indices[w].second);
						didVisitLink = false;
					}
					else
					{
						if (!IsDefined(indices[w].first)) {
							// Neighbor w has not yet been visited, push to stack for processing
							didVisitLink = true;

							// Initial visit actions (similar to the start of the recursive function)
							indices[w] = { currIndex, currIndex }; // Set the depth index for v to the smallest unused index
							++currIndex;
							nodeStack.emplace_back(w);
							assert(!onStackFlag[w]);
							onStackFlag[w] = true;

							stack.emplace_back(w, link1[w], false);
							continue; // recurse by iteration
						}
						else if (onStackFlag[w].value()) {
							// Successor w is in stack S and hence in the current SCC
							// If w is not on stack, then (v, w) is an edge pointing to an SCC already found and must be ignored
							// The next line may look odd - but is correct.
							// It says w.index not w.lowlink; that is deliberate and from the original paper
							MakeMin(indices[v].second, indices[w].first);
						}
						// Move to the next link
					}
					currentLink = nextLink1[currentLink];
					goto retry; // continue processing neighbors, no do while loop to allow continue to jump to processing next or previous stack frame
				}
				// Final actions (similar to the end of the recursive function)
				// If v is a root node, pop the stack and generate an SCC
				if (indices[v].first == indices[v].second)
				{
					// start a new strongly connected component
					// use nrParts (initially zero) as chrono-number for accessing timedParLinkLinkedList
					if (nrParts >= timedParLinkLinkedList.size())
					{
						timedParLinkLinkedList = OwningPtrSizedArray< std::pair < PartType, PartType>>(nrParts * 2, dont_initialize MG_DEBUG_ALLOCATOR_SRC("timedParLinkLinkedList"));
						for (PartType i = 0; i != nrParts; ++i)
							timedParLinkLinkedList[i].first = UNDEFINED_VALUE(NodeType);
					}
					else
					{
						timedParLinkLinkedList[nrParts-1].first = UNDEFINED_VALUE(NodeType);
					}
					PartType lastSubPart = UNDEFINED_VALUE(PartType);

					NodeType w;
					do {
						w = nodeStack.back(); nodeStack.pop_back();
						assert(onStackFlag[w]);
						onStackFlag[w] = false;
						resSubData[w] = nrParts; // add w to current strongly connected component

						for (LinkType e = link1[w]; IsDefined(e); e = nextLink1[e])
						{
							NodeType ww = node2Data[e];
							PartType pp = resSubData[ww];
							if (IsDefined(pp))
							{
								assert(pp <= nrParts);
								if (pp < nrParts)
								{
									// set the chronos of pp to the current part to avoid adding pp to the partLinks of the current part more than once
									// aka Lazy Initialization
									if (timedParLinkLinkedList[pp].first != nrParts)
									{
										timedParLinkLinkedList[pp].second = lastSubPart;
										lastSubPart = pp;
										timedParLinkLinkedList[pp].first= nrParts; 
									}
								}
							}
						}
					} while (w != v);
					while (IsDefined(lastSubPart))
					{
						partLinks.emplace_back(Couple<PartType>(nrParts, lastSubPart));
						assert(timedParLinkLinkedList[lastSubPart].first == nrParts);
						lastSubPart = timedParLinkLinkedList[lastSubPart].second;
					}
					++nrParts;
				}
				stack.pop_back(); 
			}
		}
