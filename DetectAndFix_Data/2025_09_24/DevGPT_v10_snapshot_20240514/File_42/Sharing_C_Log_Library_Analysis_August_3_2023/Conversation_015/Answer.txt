这些宏定义是用来在代码中方便地记录日志的。它们使用了 C++ 的预处理器指令 `#define` 来定义宏，并使用 `&&` 运算符来实现条件日志记录。这样，只有在日志级别大于等于系统设置的日志级别时，日志才会被记录。

让我们逐一分析这些宏：

[CODE_BLOCK_0]
`NANO_LOG` 宏定义生成一条新的日志行，并将其添加到 `nanolog::NanoLog` 对象中。这个宏接受一个参数 `LEVEL`，表示日志的级别。它还使用了预定义的宏 `__FILE__`、`__func__` 和 `__LINE__` 来获取并记录日志事件发生的源文件名、函数名和行号。

[CODE_BLOCK_1]
`LOG_INFO` 宏首先检查 `INFO` 级别的日志是否应该被记录（由 `nanolog::is_logged` 函数确定），如果应该被记录，那么它就使用 `NANO_LOG` 宏来生成并添加一条 `INFO` 级别的日志。

[CODE_BLOCK_2]
`LOG_WARN` 宏的工作方式与 `LOG_INFO` 宏类似，只不过它是用于 `WARN` 级别的日志。

[CODE_BLOCK_3]
`LOG_CRIT` 宏的工作方式也与 `LOG_INFO` 宏类似，只不过它是用于 `CRIT` 级别的日志。

这些宏定义使得在代码中记录日志变得非常简单。你只需要在你想记录日志的地方使用对应的宏，然后提供一个格式化的消息和相应的参数。例如：

[CODE_BLOCK_4]