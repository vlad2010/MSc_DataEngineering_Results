class FileWriter {
	public:
		FileWriter(std::string const& log_directory, std::string const& log_file_name, uint32_t log_file_roll_size_mb)
			: m_log_file_roll_size_bytes(log_file_roll_size_mb * 1024 * 1024), m_name(log_directory + log_file_name)
		{
			roll_file();
		}

		void write(NanoLogLine& logline) {
			auto pos = m_os->tellp();//获取当前输出流的写入位置指针
			logline.stringify(*m_os);
			m_bytes_written += m_os->tellp() - pos;
			if (m_bytes_written > m_log_file_roll_size_bytes) {
				roll_file();
			}
		}

	private:
		//将输出流的二进制数据写入文件，并建立新日志文件
		void roll_file() {
			if (m_os) {
				m_os->flush();
				m_os->close();
			}

			m_bytes_written = 0;
			m_os.reset(new std::ofstream());

			std::string log_file_name = m_name;
			log_file_name.append(".");
			log_file_name.append(std::to_string(++m_file_number));
			log_file_name.append(".txt");

			m_os->open(log_file_name, std::ofstream::out | std::ofstream::trunc);
		}

	private:
		uint32_t m_file_number = 0;//表示写到第几个文件了
		std::streamoff m_bytes_written = 0;
		uint32_t const m_log_file_roll_size_bytes;//每个文件的最大字节数
		std::string const m_name;//保存日志文件的完整路径（路径+文件名）
		std::unique_ptr<std::ofstream> m_os;
	};
逐行分析